
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Temporal preprocessing &#8212; NI-edu</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Spatial preprocessing" href="spatial_preprocessing.html" />
    <link rel="prev" title="Preprocessing" href="../../section_intros/4_preprocessing.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/fmri.gif" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">NI-edu</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Welcome to NI-edu
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/about.html">
   About this course
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/installation.html">
   Installation
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  fMRI-introduction
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/1_python.html">
   Python for (f)MRI analysis
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../other/python_recap.html">
     Python recap
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_1/python_for_mri.html">
     Working with MRI data in Python (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/2_glm.html">
   Using the GLM to model fMRI data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_2/glm_part1_estimation.html">
     The GLM: estimation (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/glm_part2_inference.html">
     The GLM: inference (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/3_design_of_experiments_T.html">
   Design of experiments
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/design_of_experiments.html">
     Design of experiments (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/neurodesign.html">
     Neurodesign (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../../section_intros/4_preprocessing.html">
   Preprocessing
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Temporal preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="spatial_preprocessing.html">
     Spatial preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fmriprep.html">
     Fmriprep (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/5_multilevel.html">
   First &amp; run-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/linux_and_the_command_line.html">
     Linux and the CMD (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/first_level_analyses.html">
     First level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/run_level_analyses.html">
     Run-level analyses (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/6_grouplevel.html">
   Group-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/group_level_analyses.html">
     Group-level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/MCC.html">
     Multiple comparison correction (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/ROI_analysis.html">
     ROI analysis (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/7_nilearn.html">
   Introduction to Nilearn
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_7/nilearn.html">
     Introduction to Nilearn (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_7/nilearn_stats.html">
     Statistics with Nilearn (T)
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  fMRI-pattern-analysis
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_1/design_and_pattern_estimation.html">
   Design and pattern estimation (T)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_2/decoding_analyses.html">
   Machine learning/decoding (T)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_3/rsa.html">
   Representational Similarity Analysis (T)
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Misc
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/bibliography.html">
   Bibliography
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/for_educators.html">
   For educators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONTRIBUTING.html">
   Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONDUCT.html">
   Code of Conduct
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/fMRI-introduction/week_4/temporal_preprocessing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/lukassnoek/NI-edu"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/lukassnoek/NI-edu/issues/new?title=Issue%20on%20page%20%2FfMRI-introduction/week_4/temporal_preprocessing.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/lukassnoek/NI-edu/edit/master/NI-edu/fMRI-introduction/week_4/temporal_preprocessing.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/lukassnoek/NI-edu/master?urlpath=tree/NI-edu/fMRI-introduction/week_4/temporal_preprocessing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        <a class="jupyterhub-button" href="https://neuroimaging.lukas-snoek.com/hub/user-redirect/git-pull?repo=https://github.com/lukassnoek/NI-edu&urlpath=tree/NI-edu/NI-edu/fMRI-introduction/week_4/temporal_preprocessing.ipynb&branch=master"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="../../_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-t-value-formula-yet-again">
     The
     <em>
      t
     </em>
     -value formula — yet again
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#on-temporal-vs-spatial-preprocessing">
     On temporal vs. spatial preprocessing
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   Temporal preprocessing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#slice-time-correction">
     Slice-time correction
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-short-primer-on-the-frequency-domain-and-the-fourier-transform">
     A short primer on the frequency domain and the Fourier transform
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#frequency-characteristics-of-fmri-data">
     Frequency characteristics of fMRI data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#two-approaches-to-temporal-preprocessing">
     Two approaches to temporal preprocessing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#high-pass-filtering-of-fmri-data-option-1">
     High-pass filtering of fMRI data (option 1)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#high-pass-filtering-of-fmri-data-option-2">
     High-pass filtering of fMRI data (option 2)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#autocorrelation-and-prewhitening">
   Autocorrelation and prewhitening
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#assumption-of-zero-mean-of-the-residuals">
     Assumption of zero-mean of the residuals
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#equal-variance-of-the-residuals">
     Equal variance of the residuals
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zero-covariance-between-residuals">
     Zero covariance between residuals
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#accounting-for-unequal-variance-and-autocorrelation-prewhitening">
     Accounting for unequal variance and autocorrelation: prewhitening
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#more-on-nuisance-regression">
   (More on) nuisance regression
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-nuisance-regression-for-despiking">
     Using nuisance regression for despiking
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="temporal-preprocessing">
<h1>Temporal preprocessing<a class="headerlink" href="#temporal-preprocessing" title="Permalink to this headline">¶</a></h1>
<p>Preprocessing of (f)MRI data is quite a complex topic, involving techniques from signal processing (filtering), linear algebra/statistics (prewhitening, autocorrelation correction), and numerical optimization (image registration). Additionally, there is ongoing discussion about which preprocessing steps are necessary/sufficient and what preprocessing parameters are optimal. As always, this depends on your specific research question, the type and quality of your data, and the intended analysis.</p>
<p>In this week, we’ll discuss a couple (not all!) of preprocessing steps that are common in univariate fMRI analyses across two notebooks, one discussing temporal processing (the current notebook) and one discussing spatial preprocessing (the next notebook, <code class="docutils literal notranslate"><span class="pre">spatial_preprocessing.ipynb</span></code>).</p>
<p><strong>What you’ll learn</strong>: after this lab, you’ll …</p>
<ul class="simple">
<li><p>be able to explain the influence of preprocessing on the measured effects using the t-value formula</p></li>
<li><p>understand (the advantage of) temporal filtering from both the time-domain and frequency-domain</p></li>
<li><p>understand the necessity of prewhitening given the assumptions of the GLM</p></li>
<li><p>understand the advantage of spatial filtering (smoothing)</p></li>
<li><p>understand how to handle outliers</p></li>
<li><p>know how to implement the concepts above in Python</p></li>
</ul>
<p><strong>Estimated time needed to complete</strong>: 8-12 hours</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>As we said before, preprocessing is a topic that almost warrants its own course. Nonetheless, we’ll try to show you (and let you practice with) some of the most common and important preprocessing operations. Additionally, we’ll introduce the concept of the fast fourier transform, which allows us to analyze our signal in the frequency domain, which helps to understand several preprocessing steps, such as temporal filtering.</p>
<div class="section" id="the-t-value-formula-yet-again">
<h3>The <em>t</em>-value formula — yet again<a class="headerlink" href="#the-t-value-formula-yet-again" title="Permalink to this headline">¶</a></h3>
<p>The previous two weeks, you have learned that, essentially, we want to find large effects (calculated as <em>t</em>-values) of our contrasts by optimizing various parts of the <em>t</em>-value formula. Conceptually, the <em>t</em>-value formula for a particular contrast (<span class="math notranslate nohighlight">\(\mathbf{c}\)</span>) can be written as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-fd4587b1-8831-4649-9e17-a5aea60a6081">
<span class="eqno">(47)<a class="headerlink" href="#equation-fd4587b1-8831-4649-9e17-a5aea60a6081" title="Permalink to this equation">¶</a></span>\[\begin{align}
t\mathrm{-value} = \frac{\mathrm{effect}}{\mathrm{uncertainty}} = \frac{\mathrm{effect}}{\sqrt{\mathrm{noise} \cdot \mathrm{design\ variance}}} = \frac{\mathbf{c}\hat{\beta}}{\sqrt{\hat{\sigma}^{2}\mathbf{c}(\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{c}^{T}}}
\end{align}\]</div>
<p>Last week you’ve learned that by ensuring low design variance (through <em>high</em> predictor variance and <em>low</em> predictor correlations) leads to larger normalized effects (higher <em>t</em>-values). This week, we will discuss the other term of the denominator of this formula: the noise (also called the residual variance or unexplained variance), which is defined in the <em>t</em>-value formula as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-7363ba7b-5ea4-4a73-ba50-712728f99178">
<span class="eqno">(48)<a class="headerlink" href="#equation-7363ba7b-5ea4-4a73-ba50-712728f99178" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathrm{noise} = \frac{\mathrm{SSE}}{\mathrm{DF}} = \frac{\sum_{i=1}^{N}(y_{i} - \hat{y}_{i})^{2}}{N - P}
\end{align}\]</div>
<p>Through preprocessing, we aim to reduce the difference between our prediction (<span class="math notranslate nohighlight">\(\hat{\mathbf{y}}\)</span>) and our true signal (<span class="math notranslate nohighlight">\(\mathbf{y}\)</span>), thus reducing the noise-term of the formula and thereby optimizing our (“normalized”) effects.</p>
</div>
<div class="section" id="on-temporal-vs-spatial-preprocessing">
<h3>On temporal vs. spatial preprocessing<a class="headerlink" href="#on-temporal-vs-spatial-preprocessing" title="Permalink to this headline">¶</a></h3>
<p>Roughly speaking, you can divide fMRI preprocessing into two types of operations: temporal and spatial. Temporal preprocessing involves operations that filter or otherwise affect the properties of your data across the time dimension (i.e., the time series). This is, of course, only applicable to <em>functional</em> MRI data (not structural or diffusion MRI). Examples of temporal operations are high-pass filtering and slice-time correction. Spatial preprocessing involves operations that filter or otherwise affect the spatial properties of your data (such as spatial orienatation, resolution, and shape). Examples of these spatial operations are spatial filtering (“smoothing”), distortion correction, motion correction (realignment), and spatial normalization/resampling.</p>
<p>In this lab, we’ll discuss these operations per theme: we’ll start with temporal operations and then move to spatial operations. Note that this <em>is not</em> the order in which data is usually preprocessed (see page 35 of the “Handbook of functional MRI Data Anslysis” textbook).</p>
<p>Let’s start with temporal preprocessing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, some imports!</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="kn">from</span> <span class="nn">nilearn.glm.first_level.hemodynamic_models</span> <span class="kn">import</span> <span class="n">glover_hrf</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>Temporal preprocessing<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will discuss how temporal preprocessing may greatly reduce the error term of our statistics. We’ll also delve into a variant of the GLM that deals with autocorrelation in our signals appropriately (“generalized least squares”, or GLS).</p>
<div class="section" id="slice-time-correction">
<h3>Slice-time correction<a class="headerlink" href="#slice-time-correction" title="Permalink to this headline">¶</a></h3>
<p>Slice-time correction is a temporal resampling technique that corrects for the fact that, in (most) BOLD-MRI scan sequences, volumes are acquired slice by slice. This means that each slices is acquired at a slightly different time. For example, suppose that we are acquiring an fMRI run with a TR of 2 seconds and our volumes consist of 40 slices (acquired axially, inferior → superior). In this case, the acquisition of each slice takes <span class="math notranslate nohighlight">\(\frac{TR}{N_{slice}} = \frac{2}{40} = 0.05\)</span> seconds (let’s call this <code class="docutils literal notranslate"><span class="pre">dt</span></code>). This means that, for the very first volume, the “onset” of the first slice is at 0 seconds (and lasts until 0.05 seconds), while the onset of the last slice is at 1.95 (and lasts until 2.00 seconds). In code, we can calculate these slice onsets <strong>within a volume</strong> using the <code class="docutils literal notranslate"><span class="pre">np.linspace(start,</span> <span class="pre">stop,</span> <span class="pre">n_steps)</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">TR</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_slices</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">slice_onsets_within_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TR</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Note, this would have worked as well: np.arange(0, TR, TR / 40)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Length of slice onsets: </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">slice_onsets_within_volume</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Onsets of slices for first volume: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slice_onsets_within_volume</span><span class="p">,),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acquisition of first slice (of first volume) started at </span><span class="si">%.2f</span><span class="s2"> sec.&quot;</span> <span class="o">%</span> <span class="n">slice_onsets_within_volume</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acquisition of last slice (of first volume) started at </span><span class="si">%.2f</span><span class="s2"> sec.&quot;</span> <span class="o">%</span> <span class="n">slice_onsets_within_volume</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Length of slice onsets: 40

Onsets of slices for first volume: [0.   0.05 0.1  0.15 0.2  0.25 0.3  0.35 0.4  0.45 0.5  0.55 0.6  0.65
 0.7  0.75 0.8  0.85 0.9  0.95 1.   1.05 1.1  1.15 1.2  1.25 1.3  1.35
 1.4  1.45 1.5  1.55 1.6  1.65 1.7  1.75 1.8  1.85 1.9  1.95]

Acquisition of first slice (of first volume) started at 0.00 sec.
Acquisition of last slice (of first volume) started at 1.95 sec.
</pre></div>
</div>
</div>
</div>
<p>Now, let’s assume we do a very simple experiment, lasting 32 seconds (i.e., 16 volumes with a TR of 2), in which we show a single stimulus at <span class="math notranslate nohighlight">\(t=0\)</span>. Furthermore, let’s assume that the <em>entire brain</em> responds to this stimulus with an idealized (noiseless response). In other words, the response of each voxel will look exactly like the HRF:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">oversampling</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">exp_length</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">n_vols</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">//</span> <span class="n">TR</span>

<span class="n">ideal_response</span> <span class="o">=</span> <span class="n">glover_hrf</span><span class="p">(</span><span class="n">tr</span><span class="o">=</span><span class="n">TR</span><span class="p">,</span> <span class="n">time_length</span><span class="o">=</span><span class="n">exp_length</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="n">TR</span> <span class="o">*</span> <span class="n">oversampling</span><span class="p">)</span>
<span class="n">ideal_response</span> <span class="o">/=</span> <span class="n">ideal_response</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_length</span><span class="p">,</span> <span class="n">ideal_response</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ideal_response</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Idealized response of all voxels&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (seconds)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_8_0.png" src="../../_images/temporal_preprocessing_8_0.png" />
</div>
</div>
<p>We must, however, take into accout that, even when our data would represent an idealized response, it would be sampled at different timepoints due to a difference in onsets for different slices. The first slice would for example be sampled at <span class="math notranslate nohighlight">\([0, 2, 4, 6, ..., 30]\)</span> seconds, while, for example, the middle slice would be sampled at <span class="math notranslate nohighlight">\([1, 3, 5, ... 31]\)</span> seconds. We can calculate the onset per slice <strong>across volumes</strong> using <code class="docutils literal notranslate"><span class="pre">np.linspace</span></code> again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: this is the onset of slice number &quot;slice_num&quot; **across volumes**</span>
<span class="n">onsets_slice_across_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">slice_num</span><span class="p">,</span> <span class="n">length_exp</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">slice_num</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">dt</span></code> is the time it takes per slice (i.e., <span class="math notranslate nohighlight">\(dt = \frac{TR}{N_{slice}}\)</span>). So, to get the slice times for, e.g. slice number 23, for the experiment we have so far (i.e., with a TR of 2, 40 slices, and 32 second duration), we would compute the onsets as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">TR</span> <span class="o">/</span> <span class="n">n_slices</span>
<span class="n">slice_num</span> <span class="o">=</span> <span class="mi">23</span>

<span class="c1"># note the slice_num - 1, as Python uses 0-based indexing</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">slice_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">exp_length</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">slice_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">onsets_slice23_across_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">onsets_slice23_across_volumes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.1  3.1  5.1  7.1  9.1 11.1 13.1 15.1 17.1 19.1 21.1 23.1 25.1 27.1
 29.1 31.1]
</pre></div>
</div>
</div>
</div>
<p>So, even with a noiseless response, the data will look different per slice. We’ll plot this below for the first slice and the middle slice (on top of the idealized response):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">onsets_s0_across_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_length</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">onsets_s20_across_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="mi">19</span><span class="p">,</span> <span class="n">exp_length</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="mi">19</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Onset acquisition of slice 0 (first 10 volumes): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">onsets_s0_across_volumes</span><span class="p">[:</span><span class="mi">10</span><span class="p">],))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Onset acquisition of slice 20 (first 10 volumes): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">onsets_s20_across_volumes</span><span class="p">[:</span><span class="mi">10</span><span class="p">],))</span>

<span class="c1"># &quot;Fit&quot; the interpolation </span>
<span class="n">resampler</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ideal_response</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ideal_response</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Resampled slicewise responses&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (seconds)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="k">for</span> <span class="n">onsets</span> <span class="ow">in</span> <span class="p">[</span><span class="n">onsets_s0_across_volumes</span><span class="p">,</span> <span class="n">onsets_s20_across_volumes</span><span class="p">]:</span>
    <span class="c1"># Do not use this code as an example to solve the next ToDo!</span>
    <span class="c1"># Because it does it the other way around.</span>
    <span class="n">slice_sig</span> <span class="o">=</span> <span class="n">resampler</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span>  <span class="c1"># resample to slice times! kind of like inverse slice-time correction</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">slice_sig</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Idealized response&#39;</span><span class="p">,</span> <span class="s1">&#39;Actual response slice 0&#39;</span><span class="p">,</span> <span class="s1">&#39;Actual response slice 20&#39;</span><span class="p">],</span>
           <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Onset acquisition of slice 0 (first 10 volumes): [ 0.  2.  4.  6.  8. 10. 12. 14. 16. 18.]
Onset acquisition of slice 20 (first 10 volumes): [ 0.95  2.95  4.95  6.95  8.95 10.95 12.95 14.95 16.95 18.95]
</pre></div>
</div>
<img alt="../../_images/temporal_preprocessing_12_1.png" src="../../_images/temporal_preprocessing_12_1.png" />
</div>
</div>
<p>Now, if we would ignore the fact that these signals were acquired at different times (by assuming they were all acquired at <span class="math notranslate nohighlight">\(t=0, t=2, t=4\)</span> etc.), our model will be suboptimal for all slices (except for slice 0). We’ll show this below by plotting the resampled data from  slice 0, 20, and 39 on top of the idealized response (which represents our predictor):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">slice_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">slice_sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">slice_onsets_across_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">slice_sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">39</span><span class="p">]):</span>
    <span class="n">t_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">slc</span><span class="p">,</span> <span class="n">exp_length</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">slc</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">slice_resp</span> <span class="o">=</span> <span class="n">resampler</span><span class="p">(</span><span class="n">t_slice</span><span class="p">)</span>
    <span class="n">slice_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_resp</span>  <span class="c1"># save for later</span>
    <span class="n">slice_onsets_across_volumes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_slice</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ideal_response</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">onsets_s0_across_volumes</span><span class="p">,</span> <span class="n">slice_resp</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Slice </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (seconds)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="s1">&#39;Actual response&#39;</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_14_0.png" src="../../_images/temporal_preprocessing_14_0.png" />
</div>
</div>
<p>As you can see, “later” slices are quite misaligned relative to the idealized response/model (which assume that each slice is acquired at the start of the volume). We can fix this by <em>resampling the data from different slices to the onset times of a reference slice</em>. Basically, this amounts to saying: “what would the signal from slice x look like if it was acquired at the onsets of a reference slice”. This process is called <em>slice-time correction</em>.</p>
<p>Remember the temporal resampling of our “high precision” predictors that we did in week 2? We’re going to do something similar to our data, here. Basically, we are going to resample our slice-wise timesieres corresponding to a particular set of onsets (let’s call these the <code class="docutils literal notranslate"><span class="pre">original_onsets</span></code>) to the set of onsets of a particular reference slice (let’s call these the <code class="docutils literal notranslate"><span class="pre">desired_onsets</span></code>). Using the same <code class="docutils literal notranslate"><span class="pre">interp1d</span></code> function from week 2, we can do the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">resampler</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">original_onsets</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">)</span>
<span class="n">std_signal</span> <span class="o">=</span> <span class="n">resampler</span><span class="p">(</span><span class="n">desired_onsets</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">original_onsets</span></code> is a numpy array with onsets of each slice <strong>across volumes</strong> and the <code class="docutils literal notranslate"><span class="pre">original_signal</span></code> refers to the actual signal of that voxel (here: slice). They should be the same size. The <code class="docutils literal notranslate"><span class="pre">desired_onsets</span></code> is another numpy array with, <em>in the case of slice-time correction</em>, the same size as <code class="docutils literal notranslate"><span class="pre">original_onsets</span></code>.</p>
<p>Below, we’ll pick the first slice as the reference slice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slice_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">onsets_s0_across_volumes</span><span class="p">,</span> <span class="n">slice_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Original slicewise responses&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

<span class="c1"># Define reference slice as the first one (with onsets [0, 2, 4, 6, etc])</span>
<span class="n">desired_onsets</span> <span class="o">=</span> <span class="n">onsets_s0_across_volumes</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slice_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    
    <span class="c1"># Resample slice-specific onsets to desired onsets</span>
    <span class="n">resampler</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">slice_onsets_across_volumes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">slice_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
    <span class="n">stc_slice</span> <span class="o">=</span> <span class="n">resampler</span><span class="p">(</span><span class="n">desired_onsets</span><span class="p">)</span>
    
    <span class="c1"># Plot relative to the reference onsets, i.e., onsets_s0 (first slice)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">onsets_s0_across_volumes</span><span class="p">,</span> <span class="n">stc_slice</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Slice-time corrected data&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (seconds)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_16_0.png" src="../../_images/temporal_preprocessing_16_0.png" />
</div>
</div>
<p>As you can see, the resampled time series resemble each other much more after slice-time correction! It’s showing some “edge artifacts” which are caused by extrapolation of the time series. In actual neuroimaging software packages, higher-order resampling (such as “cubic” or “spline” resampling) are used to somewhat mitigate this. Moreover, instead of the first slice, usually the middle slice is chosen as the reference slice, which reduces the amount of resampling (and extrapolation) that has to be done, further mitigating artifacts.</p>
<div class='alert alert-warning'>
<b>ToDo</b> (2 points):
<p><em>Note</em>: this is a difficult ToDo!</p>
<p>Below, we load in new data (<tt>slice_data</tt>) from a very short experiment (60 seconds, TR = 3). The data are from 1 voxel from every of the 32 slices. Implement slice-time correction by resampling each slice to the onsets of the middle slice (slice no. 16). Use “cubic” interpolation (by setting <tt>kind=”cubic”</tt> when initializing your resampler). Please store the results in the pre-allocated array <tt>stc_data</tt>.</p>
<p>Tip 1: define the TR, number of volumes, length of experiment, and <tt>dt</tt>.<br>
Tip 2: before looping over the different slices, define the onsets of the reference slice (remember: Python is 0-indexed).<br>
Tip 3: you have to initialize your resampler again for every iteration of your loop!<br>
Tip 4: when initializing your resampler, set <tt>fill_value=’extrapolate’</tt>.
Tip 5: plot your data before and after slice-time correction to see whether it worked properly (it should show you more-or-less aligned timeseries after STC, which may still show some differences in amplitude). Not part of the ToDo, but a good way to check your implementation.</p>
<p>Note: this is a ToDo which requires a little more code than usual!</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">slice_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;stc_data.npy&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Slice data is of shape (time x slices): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slice_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>

<span class="n">stc_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">slice_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot; Tests the above ToDo. &quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_stc_todo</span>
<span class="n">test_stc_todo</span><span class="p">(</span><span class="n">slice_data</span><span class="p">,</span> <span class="n">stc_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="a-short-primer-on-the-frequency-domain-and-the-fourier-transform">
<h3>A short primer on the frequency domain and the Fourier transform<a class="headerlink" href="#a-short-primer-on-the-frequency-domain-and-the-fourier-transform" title="Permalink to this headline">¶</a></h3>
<p>Now, before we’ll delve into important temporal preprocessing operations, let’s discuss how we can represent time series in the frequency domain using the Fourier transform.</p>
<p>Thus far, we’ve always looked at our fMRI-signal as activity that varies across <strong>time</strong>. In other words, we’re always looking at the signal in the <em>time domain</em>. However, there is also a way to look at a signal in the <em>frequency domain</em> (also called ‘spectral domain’) through transforming the signal using the <em>Fourier transform</em>.</p>
<p>Basically, the fourier transform calculates to which degree sine waves of different frequencies are present in your signal. If a sine wave of a certain frequency (let’s say 2 hertz) is (relatively) strongly present in your signal, it will have a (relatively) high <em>power</em> in the frequency domain. Thus, looking at the frequency domain of a signal can tell you something about the frequencies of the (different) sources underlying your signal.</p>
<p>This may sound quite abstract, so let’s look at some examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># start with importing the python packages we&#39;ll need </span>
<span class="kn">from</span> <span class="nn">niedu.utils.nii</span> <span class="kn">import</span> <span class="n">create_sine_wave</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
</pre></div>
</div>
</div>
</div>
<p>Sine waves are oscillating signals that have (for our purposes) two important characteristics: their <em>frequency</em> and their <em>amplitude</em>. Frequency reflects how fast a signal is oscillating (how many cycles it completes in a given time period) and the amplitude is the (absolute) height of the peaks and troughs of the signal. To illustrate this, we generate a couple of sine-waves (with a sampling rate of 500 Hz, i.e., 500 samples per second) with different amplitudes and frequencies, which we plot below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">max_time</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">timepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_time</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>

<span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">sines</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">amp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">):</span>
    
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
        <span class="n">this_ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">this_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Activity (A.U.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">this_ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (seconds)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        
        <span class="n">sine</span> <span class="o">=</span> <span class="n">create_sine_wave</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amp</span><span class="p">)</span>    
        <span class="n">sines</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sine</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span>
        <span class="n">this_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">sine</span><span class="p">)</span>
        <span class="n">this_ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">this_ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Amp = </span><span class="si">%i</span><span class="s1">, freq = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">freq</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="n">this_ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">)</span>
        <span class="n">this_ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_24_0.png" src="../../_images/temporal_preprocessing_24_0.png" />
</div>
</div>
<p>As you can see, the signals vary in their amplitude (from 1 to 3) and their frequency (from 1 - 3). Make sure you understand these characteristics! Now, we are going to use the fast fourier transform to plot the same signals in the <em>frequency domain</em>. We’re not going to use a function to compute the FFT-transformation, but we’re going to use a function that computes the “power spectrum density” directly (which makes life a little bit easier): the <code class="docutils literal notranslate"><span class="pre">periodogram</span></code> function from <code class="docutils literal notranslate"><span class="pre">scipy.signal</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>
</pre></div>
</div>
</div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">periodogram</span></code> function takes two arguments, the signal and the sampling frequency (the sampling rate in Hz with which you recorded the signal), and returns both the reconstructed frequencies and their associated power values. An example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">some_signal</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># sampling_rate = 1000 Hz</span>
</pre></div>
</div>
<p>We’ll use the <code class="docutils literal notranslate"><span class="pre">periodogram</span></code> function to plot the 9 sine-waves (from the previous plot) again, but this time in the frequency domain:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
    <span class="n">sine</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">sines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Sine with amp = </span><span class="si">%i</span><span class="s1"> and freq = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
    <span class="n">freq</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">sine</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_28_0.png" src="../../_images/temporal_preprocessing_28_0.png" />
</div>
</div>
<p>As you can see, the frequency domain correctly ‘identifies’ the amplitudes and frequencies from the signals. But the real ‘power’ from fourier transforms is that they can reconstruct a signal in <em>multiple underlying oscillatory sources</em>. Let’s see how that works. We’re going to load in a time-series recorded for 5 seconds of which we don’t know the underlying oscillatory sources. First, we’ll plot the signal in the time-domain:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystery_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;mystery_signal.npy&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">),</span> <span class="n">mystery_signal</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Time domain&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (sec.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Activity (A.U.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_30_0.png" src="../../_images/temporal_preprocessing_30_0.png" />
</div>
</div>
<div class='alert alert-warning'>
<b>ToDo</b> (2 points): It's hard to see which frequencies (and corresponding amplitudes) are present in this 'mystery signal'. Get the frequencies and power of the signal using the <tt>periodogram</tt> function (you have to deduce the sampling rate of the signal yourself! It is *not* the variable <tt>sampling_rate</tt> from before). Set the x-limit of the x-axis to (0, 8) (<tt>plt.xlim(0, 8)</tt>). Also, give the plot appropriate labels for the axes.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement your ToDo here</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now you know that you can use visualization of the signal in the frequency domain to help you understand from which underlying frequencies your signal is built up. Unfortunately, real fMRI data is not so ‘clean’ as the simulated sine waves we have used here, but the frequency representation of the fMRI signal can still tell us a lot about the nature and contributions of different (noise- and signal-related) sources!</p>
</div>
<div class="section" id="frequency-characteristics-of-fmri-data">
<h3>Frequency characteristics of fMRI data<a class="headerlink" href="#frequency-characteristics-of-fmri-data" title="Permalink to this headline">¶</a></h3>
<p>Now, we will load a (much noisier) voxel signal and the corresponding design-matrix (which has just one predictor apart from the intercept). The signal was measured with a TR of 2 seconds and contains 300 volumes (timepoints), so the duration was 600 seconds. The predictor reflects an experiment in which we showed 15 stimuli in intervals of 40 seconds (i.e., one stimulus every 40 seconds).</p>
<p>We’ll plot both the signal (<span class="math notranslate nohighlight">\(y\)</span>) and the design-matrix (<span class="math notranslate nohighlight">\(X\)</span>; without intercept):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">niedu.utils.nii</span> <span class="kn">import</span> <span class="n">simulate_signal</span>

<span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="n">sig</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">simulate_signal</span><span class="p">(</span>
    <span class="n">onsets</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;stim&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">onsets</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
    <span class="n">duration</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
    <span class="n">TR</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">icept</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">params_canon</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
    <span class="n">std_noise</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">rnd_seed</span><span class="o">=</span><span class="mi">29</span><span class="p">,</span>
    <span class="n">phi</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># trim off the temporal derivative</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of X: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of y (sig): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Signal in time domain&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Activity (a.u.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;tab:orange&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Predictor in time domain&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (TR)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Activity (a.u.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shape of X: (300, 2)
Shape of y (sig): (300,)
</pre></div>
</div>
<img alt="../../_images/temporal_preprocessing_35_1.png" src="../../_images/temporal_preprocessing_35_1.png" />
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 points): Run linear regression using the variable <tt>X</tt> (which already contains an intercept) to explain the variable <tt>sig</tt>. Calculate the model's MSE, and store this in a variable named <tt>mse_no_filtering</tt>. Then, in the next code-cell, plot the signal and the predicted signal ($\hat{y}$) in a single figure. Give the axes sensible labels and add a legend.
</div>
<p><strong>Tip</strong> (feel free to ignore): This tutorial, you’ll be asked to compute t-values, R-squared, and MSE of several models quite some times. To make your life easier, you could (but certainly don’t have to!) write a function that runs, for example, linear regression and returns the R-squared, given a design (X) and signal (y). For example, this function could look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_mse</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># you implement the code here (run lstsq, calculate yhat, etc.)</span>
    <span class="c1"># ...</span>
    <span class="c1"># and finally, after you&#39;ve computed the model&#39;s MSE, return it</span>
    <span class="k">return</span> <span class="n">r_squared</span>
</pre></div>
</div>
<p>If you’re ambitious, you can even write a single function that calculates t-values, MSE, and R-squared. This could look something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_all_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cvec</span><span class="p">):</span>
    <span class="c1"># Implement everything you want to know and return it</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">t_value</span><span class="p">,</span> <span class="n">MSE</span><span class="p">,</span> <span class="n">r_squared</span> <span class="c1"># and whatever else you&#39;ve computed!</span>
</pre></div>
</div>
<p>Doing this will save you a lot of time and may prevent you from making unneccesary mistakes (like overwriting variables, typos, etc.). Lazy programmers are the best programmers!</p>
<p>(Note: writing these functions is <em>optional</em>!)</p>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement the linear regression part of the ToDo here:</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above linear regression ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_mse_no_filtering</span>
<span class="n">test_mse_no_filtering</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mse_no_filtering</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement your y/yhat plot here (this is manually graded)</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
<b>ToThink</b> (1 point): In your plot above, you should see that the fit of your model is "off" due to some low frequency drift. Name two potential causes of drift.
</div><p>YOUR ANSWER HERE</p>
</div>
<div class="section" id="two-approaches-to-temporal-preprocessing">
<h3>Two approaches to temporal preprocessing<a class="headerlink" href="#two-approaches-to-temporal-preprocessing" title="Permalink to this headline">¶</a></h3>
<p>Basically, there are <em>two</em> ways to preprocess your data:</p>
<ol class="simple">
<li><p>Manipulating the signal (<span class="math notranslate nohighlight">\(\mathbf{y}\)</span>) <strong>directly</strong> <em>before</em> fitting your GLM-model;</p></li>
<li><p>Including “noise predictors” in your design (<span class="math notranslate nohighlight">\(\mathbf{X}\)</span>) when fitting your model;</p></li>
</ol>
<p>Often, preprocessing steps can be done both by method 1 (manipulating the signal directly) and by method 2 (including noise predictors). For example, one of the videos showed that you could apply a high-pass filter by applying a “gaussian weighted running line smoother” (the method FSL employs) <em>directly</em> on the signal (method 1) <strong>or</strong> you could add “low-frequency (drift) predictors” to the design matrix (method 2; in the video they used a ‘discrete cosine basis set’; the SPM method). In practice, both methods often yield very similar resuls. The most important thing to understand is that both methods are trying to accomplish the same goal: reduce the noise term of the model.</p>
<p>First, we will discuss how temporal and spatial filtering can <em>directly</em> filter the signal (method 1) to reduce error. Later in the tutorial, we will discuss including adding outlier-predictors and motion-predictors to the design to reduce noise (method 2).</p>
</div>
<div class="section" id="high-pass-filtering-of-fmri-data-option-1">
<h3>High-pass filtering of fMRI data (option 1)<a class="headerlink" href="#high-pass-filtering-of-fmri-data-option-1" title="Permalink to this headline">¶</a></h3>
<p>From the previous ToDo, you probably noticed that the fit of the predictor to the model was not very good. The cause for this is the slow ‘drift’ — a low-frequency signal — that prevents the model from a good fit. Using a high-pass filter — meaning that you <em>remove</em> the low-frequency signals and thus <em>pass only the high frequencies</em> — can, for this reason, improve the model fit. But before we go on with actually high-pass filtering the signal, let’s take a look at the frequency domain representation of our voxel signal:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">TR</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">sampling_frequency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">TR</span>  <span class="c1"># our sampling rate is 0.5, because our TR is 2 sec!</span>
<span class="n">freq</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power (dB)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_44_0.png" src="../../_images/temporal_preprocessing_44_0.png" />
</div>
</div>
<p>In the frequency-domain plot above, you can clearly see a low-frequency drift component at frequencies approximately below 0.01 Hz (i.e., left of the dashed red line).</p>
<div class='alert alert-info'>
<b>ToThink</b> (1 point): Apart from the low frequency drift component around 0.01 Hz, there is also a component visible at 0.025 Hz (and its <a href="https://en.wikipedia.org/wiki/Harmonic">harmonics</a> at 0.05, 0.075, 0.1, etc.). What does this component represent? Please explain (concisely).
</div><p>YOUR ANSWER HERE</p>
<p>Now, let’s get rid of that pesky low frequency drift that messes up our model! There is no guideline on how to choose the cutoff of your high-pass filter, but most recommend to use a cutoff of around 100 seconds (i.e., of 0.01 Hz). This means that any oscillation slower than 100 seconds (one cycle in 100 seconds) is removed from your signal.</p>
<p>Anyway, as you’ve seen in the videos, there are many different ways to high-pass your signal (e.g., frequency-based filtering methods vs. time-based filtering methods). Here, we demonstrate a time-based ‘gaussian running line smoother’, which is used in FSL. As you’ve seen in the videos, this high-pass filter is estimated by convolving a gaussian “kernel” with the signal (taking the element-wise product and summing the values) across time, which is schematically visualized in the image below:</p>
<p><img alt="" src="https://docs.google.com/drawings/d/e/2PACX-1vRZTMvXJDBj3HGhrMZxQy1_6T1yF7bVinpBpeIQBgVUPAM_igGXrMonQskFP_Mymy-NVvGJnsvbDhiv/pub?w=934&amp;h=649" /></p>
<p>One implementation of this filter is included in the scipy “ndimage” subpackage. Let’s import it*:</p>
<hr class="docutils" />
<p>*<strong>Note</strong>: if you’re going to restart your kernel during the lab for whatever reason, make sure to re-import this package to avoid <code class="docutils literal notranslate"><span class="pre">NameErrors</span></code> (i.e., the error that you get when you call a function that isn’t imported).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code> function takes two mandatory input: some kind of (n-dimensional) signal and a cutoff, “sigma”, that refers to the width of the gaussian filter in standard deviations. “What? We decided to define our cutoff in seconds (or, equivalently, Hz), right?”, you might think. For some reason neuroimaging packages seem to define cutoff for their temporal filters in <strong>seconds</strong> while more ‘low-level’ filter implementations (such as in scipy) define cutoffs (of gaussian filters) in <strong>the width of the gaussial filter</strong>, i.e., <strong>sigma</strong>. Fortunately, there is an easy way to convert a cutoff in seconds to a cutoff in sigma, given a particular TR (in seconds):</p>
<div class="amsmath math notranslate nohighlight" id="equation-b629852f-23f5-4f08-964a-88fb3a1d4c9c">
<span class="eqno">(49)<a class="headerlink" href="#equation-b629852f-23f5-4f08-964a-88fb3a1d4c9c" title="Permalink to this equation">¶</a></span>\[\begin{align}
\sigma = \frac{\mathrm{cutoff}_{sec}}{\sqrt{8\ln{2}} \cdot \mathrm{TR}_{sec}}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\ln{2}\)</span> refers to the natural logarithm (i.e., log with base <span class="math notranslate nohighlight">\(e\)</span>).</p>
<div class='alert alert-warning'>
<b>ToDo</b> (1 point): Suppose I acquire some fMRI data (200 volumes) with a sampling frequency of 0.25 Hz and I would like to apply a high-pass filter of 80 seconds. What sigma should I choose? Calculate sigma and store it in a variable named <tt>sigma_todo</tt>. You can use the function <tt>np.log(some_number)</tt> to evaluate the natural logarithm of a number.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement your ToDo here</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo.&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_sec2sigma</span>
<span class="n">test_sec2sigma</span><span class="p">(</span><span class="n">sec</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">ans</span><span class="o">=</span><span class="n">sigma_todo</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Importantly, the gaussian filter does not return the filtered signal itself, but the estimated low-frequency component of the data. As such, to filter the signal, we have to subtract this low-frequency component from the original signal to get the filtered signal!</p>
<p>Below, we estimate the low-frequency component using the high-pass filter first and plot it together with the original signal, which shows that it accurately captures the low-frequency drift (upper plot). Then, we subtract the low-frequency component from the original signal to create the filtered signal, and plot it together with the original signal to highlight the effect of filtering (lower plot):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">filt</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Original signal&#39;</span><span class="p">,</span> <span class="s1">&#39;Low-freq component&#39;</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Estimated low-frequency component using HP-filter&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="c1"># IMPORTANT: subtract filter from signal</span>
<span class="n">filt_sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">filt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">filt_sig</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;tab:green&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Original signal&#39;</span><span class="p">,</span> <span class="s1">&#39;Filtered signal&#39;</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Effect of high-pass filtering&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TR)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_55_0.png" src="../../_images/temporal_preprocessing_55_0.png" />
</div>
</div>
<p>The signal looks much better, i.e., it doesn’t display much drift anymore. But let’s check this by plotting the original and filtered signal in the frequency domain:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">freq</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">freq</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">filt_sig</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power (dB)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;The effect of high-pass filtering in the frequency domain&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;Original signal&quot;</span><span class="p">,</span> <span class="s2">&quot;Filtered signal&quot;</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_57_0.png" src="../../_images/temporal_preprocessing_57_0.png" />
</div>
</div>
<p>Sweet! It seems that the high-pass filtering worked as expected! But does it really improve our model fit?</p>
<div class='alert alert-warning'>
<b>ToDo</b> (1 point): We've claimed several times that high-pass filtering improves model fit, but is that really the case in our case? To find out, fit the same design (variable <tt>X</tt>) on the filtered signal (variable <tt>filt_sig</tt>) using linear regression. Calculate MSE and store it in the variable <tt>mse_with_filter</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement linear regression of X on filt_sig here!</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_mse_with_filter</span>
<span class="n">test_mse_with_filter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">filt_sig</span><span class="p">,</span> <span class="n">mse_with_filter</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
<b>ToDo</b> (2 points)
<p>So far, we’ve filtered only a single (simulated) voxel timeseries. Normally, you want to temporally filter <em>all</em> your voxels in your 4D fMRI data, of course. Below, we load in such a 4D fMRI file (<tt>data_4d</tt>), which has <span class="math notranslate nohighlight">\(50\)</span> timepoints and (<span class="math notranslate nohighlight">\(80 \cdot 80 \cdot 44 = \)</span>) <span class="math notranslate nohighlight">\(281600\)</span> voxels.</p>
<p>For this assignment, you need to apply the high-pass filter (i.e., the <tt>gaussian_filter</tt> function; use <tt>sigma=25</tt>) on each and every voxel separately, which means that you need to loop through all voxels (which amounts to three nested for-loops across all three spatial dimensions). Below, we’ve already loaded in the data. Now it’s up to you write the loops (across spatial dimensions) to filter the signal in the inner-most loop and store it in the pre-allocated <tt>data_4d_filt</tt> variable (the loop may, if implemented correctly, take about 20 seconds!).</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)),</span> <span class="s1">&#39;week_1&#39;</span><span class="p">,</span> <span class="s1">&#39;func.nii.gz&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading data from </span><span class="si">%s</span><span class="s2"> ...&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
<span class="n">data_4d</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of the original 4D fMRI scan: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_4d</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>

<span class="c1"># Here, we pre-allocate a matrix of the same shape as data_4d, in which</span>
<span class="c1"># you need to store the filtered timeseries</span>
<span class="n">data_4d_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_4d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="c1"># Test some random indices</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">data_4d_filt</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="o">-</span><span class="mf">1366.2907714</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">data_4d_filt</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="o">-</span><span class="mf">381.6953125</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">data_4d_filt</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="o">-</span><span class="mf">269.359375</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="alert alert-success">
    <b>Note</b>: when temporally filtering your fMRI data ($\mathbf{y}$), it is important to apply the <em>same filter</em> to your design matrix ($\mathbf{X}$)! This makes sure that your design matrix does not contain any "information" that is removed from the fMRI time series by the filter, anyway. Note that most neuroimaging software packages (including FSL) do this automatically.    
<p>Technically, by filtering your design matrix as well, you’re orthogonalizing your design matrix with respect to your temporal high-pass filter. If you want to know more about this, check out <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/hbm.24528">this excellent paper</a>.</p>
</div></div>
<div class="section" id="high-pass-filtering-of-fmri-data-option-2">
<h3>High-pass filtering of fMRI data (option 2)<a class="headerlink" href="#high-pass-filtering-of-fmri-data-option-2" title="Permalink to this headline">¶</a></h3>
<p>As we’ve seen, high-pass filtering using a “running line smoother” is an operation that is applied to the signal directly (before model fitting) to reduce the noise term. Another way to reduce the noise term is to include <em>noise regressors</em> (also called ‘nuisance variables/regressors’) in the design matrix. As such, we can subdivide our design matrix into “predictors of interest” (which are included to model the task/stimuli) and “noise predictors” (which aim to model the thus-far unmodelled variance). These “noise predictors” are also sometimes called “nuisance” predictors/regressors/covariates. We can now slightly reformulate our linear regression equation by dividing our design into two components, <span class="math notranslate nohighlight">\(\mathbf{X}_{\mathrm{interest}}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X}_{\mathrm{noise}}\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-58e5543f-c02e-4810-a661-be9fbfa33b83">
<span class="eqno">(50)<a class="headerlink" href="#equation-58e5543f-c02e-4810-a661-be9fbfa33b83" title="Permalink to this equation">¶</a></span>\[\begin{align}
y = \mathbf{X}_{\mathrm{interest}}\beta_{\mathrm{interest}} + \mathbf{X}_{\mathrm{noise}}\beta_{\mathrm{noise}} + \epsilon
\end{align}\]</div>
<p>Importantly, the difference between <span class="math notranslate nohighlight">\(\mathbf{X}_{\mathrm{noise}}\)</span> and <span class="math notranslate nohighlight">\(\epsilon\)</span> is that the <span class="math notranslate nohighlight">\(\mathbf{X}_{\mathrm{noise}}\)</span> term refers to noise-related activity that you <em>are able to model</em> while the <span class="math notranslate nohighlight">\(\epsilon\)</span> term refers to the noise that you <em>can’t model</em> (this is often called the “irreducible noise/error” term).</p>
<p>We can use this technique, which we’ll call “nuisance regression” (which we’ll discuss in more detail later), as an alternative to directly high-pass filtering the signal (<span class="math notranslate nohighlight">\(\mathbf{y}\)</span>). One example of this (with respect to high-pass filtering) is including a series of cosines with varying frequencies in your design, which have the same effect as a high-pass filter. This type of filter is called a “discrete cosine (basis) set”. Basically, for any given high-pass cutoff (in hertz), the “discrete cosine transform” (DTC) will yield a set of cosine regressors that is sufficient to filter out any frequency slower than your cutoff.</p>
<p>Fortunately, the <code class="docutils literal notranslate"><span class="pre">nilearn</span></code> package contains a function to calculate discrete cosine sets:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.first_level.design_matrix</span> <span class="kn">import</span> <span class="n">_cosine_drift</span> <span class="k">as</span> <span class="n">discrete_cosine_transform</span>
</pre></div>
</div>
</div>
</div>
<p>This function takes two arguments: <code class="docutils literal notranslate"><span class="pre">high_pass</span></code> (in hertz) and <code class="docutils literal notranslate"><span class="pre">frame_times</span></code> (an array with volume onsets). The signal from the previous examples (<code class="docutils literal notranslate"><span class="pre">sig</span></code>) was from an experiment lasting 600 seconds and with a TR of 2, so the volume onsets can be defined as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (0 points): Here, we assumed our volume onset at the start of the TR. But technically, the exact definition/computation of our "frame times" depends on a preprocessing step that we discussed previously. Which one?
</div><p>Now, let’s compute a discrete cosine set for a highpass cutoff of 100 seconds (i.e., 0.01 hertz):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dc_set</span> <span class="o">=</span> <span class="n">discrete_cosine_transform</span><span class="p">(</span><span class="n">high_pass</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">frame_times</span><span class="o">=</span><span class="n">frame_times</span><span class="p">)</span>
<span class="n">dc_set</span> <span class="o">=</span> <span class="n">dc_set</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove the (extra) intercept</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dc_set</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(300,)
(300, 12)
</pre></div>
</div>
</div>
</div>
<p>As you can see, the function returns a numpy array with the same number of timepoints as our signal (300) and 12 predictors (we removed the last one, because that’s an intercept). Note that it’s not super important to know how, mathematically, a discrete cosine set is created; it’s more important to understand the idea of adding these low-frequency cosine predictors to your design matrix in order to account for (“explain”) the low-frequency parts of your data.</p>
<p>Let’s plot the discrete cosine set that we created (note: we only plot the first 6 for clarity):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dc_set</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Discrete cosine set for a high-pass filter of 0.01 Hz&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TRs)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_74_0.png" src="../../_images/temporal_preprocessing_74_0.png" />
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (2  points): Add the discrete cosine set as predictors to the design (<tt>X</tt>) and store it in a new variable named <tt>X_dct</tt> (do *not* overwrite the <tt>X</tt> variable). Make sure the first two columns of <tt>X_dct</tt> are the original predictors from <tt>X</tt> followed by the DCT set. Then, run linear regression. Save the parameters ("betas") in a variable named <tt>betas_dct</tt>. Plot the predicted signal ($\hat{\mathbf{y}}$) and the signal (<tt>sig</tt>) in the same plot. Name the axis labels appropriately.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot; Implement your ToDo here. &quot;&quot;&quot;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_dct_betas</span>
<span class="n">test_dct_betas</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dc_set</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">betas_dct</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As you’ve seen in the previous ToDos, it doesn’t really matter which strategy you choose, filtering the signal directly or adding nuisance regressors to the design: both (usually) work equally well.</p>
</div>
</div>
<div class="section" id="autocorrelation-and-prewhitening">
<h2>Autocorrelation and prewhitening<a class="headerlink" href="#autocorrelation-and-prewhitening" title="Permalink to this headline">¶</a></h2>
<p>As you (should) have seen in the previous ToDos, the model fit increases tremendously after high-pass filtering! This surely is the most important reason why you should apply a high-pass filter. But there is another important reason: high-pass filters reduce the signal’s autocorrelation!</p>
<p>“Sure, but why should we care about autocorrelation?”, you might think? Well this has to with the estimation of the standard error of our model, i.e., <span class="math notranslate nohighlight">\(\hat{\sigma}^{2}\mathbf{c}(\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{c}^{T}\)</span>. As you’ve seen in the videos, the Gauss-Markov theorem states that in order for OLS to yield valid estimates (including estimates of the parameters’ standard errors) <em>the errors (residuals) have a mean of 0, have 0 covariance (i.e., are uncorrelated), and have equal variance</em>.</p>
<p>Let’s go through these three assumptions step by step. We’ll use the previously filtered signal for this.</p>
<div class="section" id="assumption-of-zero-mean-of-the-residuals">
<h3>Assumption of zero-mean of the residuals<a class="headerlink" href="#assumption-of-zero-mean-of-the-residuals" title="Permalink to this headline">¶</a></h3>
<p>First, let’s check whether the mean of the residuals is zero:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">filt_sig</span>
<span class="n">y_hat</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">b</span>
<span class="n">resids</span> <span class="o">=</span> <span class="n">filt_sig</span> <span class="o">-</span> <span class="n">y_hat</span>
<span class="n">mean_resids</span> <span class="o">=</span> <span class="n">resids</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean of residuals: %3.f&quot;</span> <span class="o">%</span> <span class="n">mean_resids</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean of residuals:   0
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
<b>ToThink</b> (1 point): What component of the design-matrix ($\mathbf{X}$) ensures that the mean of the residuals is zero? Explain (concisely) why.
</div><p>YOUR ANSWER HERE</p>
</div>
<div class="section" id="equal-variance-of-the-residuals">
<h3>Equal variance of the residuals<a class="headerlink" href="#equal-variance-of-the-residuals" title="Permalink to this headline">¶</a></h3>
<p>Alright, sweet — the first assumption seems valid for our data. Now, the next two assumptions — about equal variance of the residuals and no covariance between residuals — are trickier to understand and deal with. In the book (and videos), these assumptions are summarized in a single mathemtical statement: the covariance-matrix of the residuals not differ substantially from the identity-matrix (<span class="math notranslate nohighlight">\(\mathbf{I}\)</span>) scaled by the noise-term (<span class="math notranslate nohighlight">\(\hat{\sigma}^{2}\)</span>). Or, put in a formula:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5c425ad7-1bac-488d-97d5-c1c131096b80">
<span class="eqno">(51)<a class="headerlink" href="#equation-5c425ad7-1bac-488d-97d5-c1c131096b80" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathrm{cov}[\epsilon] = \hat{\sigma}^{2}\mathbf{I}
\end{align}\]</div>
<p>This sounds difficult, so let’s break it down. First off all, the covariance matrix of the residuals is always a symmetric matrix of shape <span class="math notranslate nohighlight">\(N \times N\)</span>, in which the <em>diagonal represents the variances</em> and the <em>off-diagonal represents the covariances</em>. For example, at index <span class="math notranslate nohighlight">\([i, i]\)</span>, the value represents the variance of the residual at timepoint <span class="math notranslate nohighlight">\(i\)</span>. At index <span class="math notranslate nohighlight">\([i, j]\)</span>, the value represents the covariance between the residuals at timepoints <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>In OLS, we assume that the covariance matrix of the residuals (<span class="math notranslate nohighlight">\(\mathrm{cov}[\epsilon]\)</span>) matches the
identity-matrix (<span class="math notranslate nohighlight">\(\mathbf{I}\)</span>) times the noise-term (<span class="math notranslate nohighlight">\(\hat{\sigma}^{2}\)</span>). The identity-matrix is simply a matrix with all zeros except for the diagonal, which contains ones. For example, the identity-matrix for a residual-array of length <span class="math notranslate nohighlight">\(8\)</span> looks like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">identity_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># makes an &quot;eye&quot;dentity matrix</span>
<span class="nb">print</span><span class="p">(</span><span class="n">identity_mat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]]
</pre></div>
</div>
</div>
</div>
<p>We can also represent this visually:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">identity_mat</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Assumed covariance matrix of residuals&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Assumed covariance matrix of residuals&#39;)
</pre></div>
</div>
<img alt="../../_images/temporal_preprocessing_86_1.png" src="../../_images/temporal_preprocessing_86_1.png" />
</div>
</div>
<p>Now, suppose we calculated that the noise-term of a model explaining this hypothetical signal of length <span class="math notranslate nohighlight">\(8\)</span> equals 2.58 (<span class="math notranslate nohighlight">\(\hat{\sigma}^{2} = 2.58\)</span>). Then, OLS <em>assumes</em> that the noise stems from a covariance matrix estimated from the residuals:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise_term</span> <span class="o">=</span> <span class="mf">2.58</span>
<span class="n">assumed_cov_resid</span> <span class="o">=</span> <span class="n">noise_term</span> <span class="o">*</span> <span class="n">identity_mat</span>
<span class="nb">print</span><span class="p">(</span><span class="n">assumed_cov_resid</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[2.58 0.   0.   0.   0.   0.   0.   0.  ]
 [0.   2.58 0.   0.   0.   0.   0.   0.  ]
 [0.   0.   2.58 0.   0.   0.   0.   0.  ]
 [0.   0.   0.   2.58 0.   0.   0.   0.  ]
 [0.   0.   0.   0.   2.58 0.   0.   0.  ]
 [0.   0.   0.   0.   0.   2.58 0.   0.  ]
 [0.   0.   0.   0.   0.   0.   2.58 0.  ]
 [0.   0.   0.   0.   0.   0.   0.   2.58]]
</pre></div>
</div>
</div>
</div>
<p>In other words, this assumption about the covariance matrix of the residuals states that the <em>variance across residuals (the diagonal of the matrix) should be equal</em> and the <em>covariance between residuals (the off-diagonal values of the matrix) should be 0</em> (in the population).</p>
<p>Now, we won’t explicitly estimate the covariance matrix of the residuals (which is usually estimated using techniques that fall beyond the scope of this course); however, we <em>do</em> want you to understand <em>conceptually</em> how fMRI data might invalidate the assumptions about the covariance matrix of the residuals and how fMRI analyses deal with this (i.e., using prewhitening, which is explained later).</p>
<p>So, let’s check <em>visually</em> whether the assumption of equal variance of our residuals roughly holds for our (simulated) fMRI data. Now, when we consider this assumption in the context of our fMRI data, the assumption of “equal variance of the residuals” (also called homoskedasticity) means that we assume that the “error” in the model is equally big across our timeseries data. In other words, the mis-modelling (error) should be constant over time.</p>
<p>Let’s check this for our data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resids</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TR)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Residuals&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_90_0.png" src="../../_images/temporal_preprocessing_90_0.png" />
</div>
</div>
<p>Looks quite alright! Sure, there is some variation here and there, but given that our estimates (including the residuals and their variance!) are imperfect, this suffices.</p>
<p>Just to give you some intuition about serious issues with homoskedasticity, check out the (hypothetical) timeseries residuals below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">example_resids</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">*</span> <span class="n">mfactor</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TR)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;An example of residuals with (problematic) unequal variance&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">example_resids</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_92_0.png" src="../../_images/temporal_preprocessing_92_0.png" />
</div>
</div>
<div class='alert alert-info'> 
<b>ToThink</b> (1 point): What could cause unequal variance in the residuals of an fMRI signal, *given that autocorrelation (i.e. low-frequency components) is filtered out appropriately*? In other words, can you think of something that might cause larger (or smaller) errors across the duration of an fMRI run?
</div><p>YOUR ANSWER HERE</p>
</div>
<div class="section" id="zero-covariance-between-residuals">
<h3>Zero covariance between residuals<a class="headerlink" href="#zero-covariance-between-residuals" title="Permalink to this headline">¶</a></h3>
<p>The last assumption of zero covariance between residuals (corresponding to the assumption of all zeros on the off-diagonal elements of the covariance-matrix of the residuals) basically refers to the assumption that <em>there is no autocorrelation (correlation in time) in the residuals</em>. In other words, knowing the residual at timepoint <span class="math notranslate nohighlight">\(i\)</span> does not tell you anything about the residual at timepoint <span class="math notranslate nohighlight">\(i+\tau\)</span>, where <span class="math notranslate nohighlight">\(\tau\)</span> reflects a particular “lag” and can be any positive number (up to <span class="math notranslate nohighlight">\(N\)</span>). For example, the “lag 1” autocorrelation (<span class="math notranslate nohighlight">\(\tau = 1\)</span>) is the correlation between the data at timepoints <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(i+1\)</span>. In OLS, we assume that there is no autocorrelation across all possible lags.</p>
<p>Take for example the residuals of our unfiltered signal from before, which looked like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">sig</span>
<span class="n">resids_new</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">X</span> <span class="o">@</span> <span class="n">b</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">resids_new</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TR)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Residuals (containing unmodelled drift!)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Activity (a.u.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_96_0.png" src="../../_images/temporal_preprocessing_96_0.png" />
</div>
</div>
<p>In the above plot, there is clear and strong autocorrelation in the residuals. For example, the residuals are overall getting larger across time (“drift”) and it contains other low-frequency (oscillatory) patterns. As such, we <em>do know something about the residual at timepoint <span class="math notranslate nohighlight">\(i+1\)</span> (and other lags) given the residual at timepoint <span class="math notranslate nohighlight">\(i\)</span>, namely that it is likely that the residual at timpoint <span class="math notranslate nohighlight">\(i+1\)</span> is likely <strong>lower</strong> than the residual at timepoint <span class="math notranslate nohighlight">\(i\)</span></em>! Therefore, drift is a perfect example of something that (if not modelled) causes autocorrelation in the residuals (i.e. covariance between residuals)! In other words, autocorrelation (e.g. caused by drift) will cause the values of the covariance matrix of the residuals at the indices <span class="math notranslate nohighlight">\([i, i+1]\)</span> to be non-zero, violating the third assumption of Gauss-Markov’s theorem!</p>
<div class='alert alert-warning'>
<b>ToDo</b> (1  point)
<p>We stated that autocorrelation captures the information that you have of the residual at timepoint <span class="math notranslate nohighlight">\(i+\tau\)</span> given that you know the residual at timepoint <span class="math notranslate nohighlight">\(i\)</span>. Practically, you can compute the autocorrelation (or actually, autocovariance) for a particular lag <span class="math notranslate nohighlight">\(\tau\)</span> by computing the covariance of the residuals with the lag-<span class="math notranslate nohighlight">\(\tau\)</span> shifted version of itself. In general, the autocovariance for the residuals <span class="math notranslate nohighlight">\(\epsilon\)</span> with lag <span class="math notranslate nohighlight">\(\tau\)</span> is calculated as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-bd38a1d7-e86c-4e48-a6a2-42d976690203">
<span class="eqno">(52)<a class="headerlink" href="#equation-bd38a1d7-e86c-4e48-a6a2-42d976690203" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathrm{cov}[\epsilon_{i}, \epsilon_{i+\tau}] = \frac{1}{N-\tau-1}\sum_{i=1}^{N-\tau}(\epsilon_{i}\cdot\epsilon_{i+\tau})
\end{align}\]</div>
<p>Jeanette Mumford explains how to do this quite clearly in her <a class="reference external" href="https://www.youtube.com/watch?v=4VSzZKO0k_w">video on prewhitening</a> (around minute 10). For this ToDo, calculate the covariance (with <span class="math notranslate nohighlight">\(\tau = 1\)</span>) between the residuals (i.e., using the variable <tt>resids_new</tt>) and store this in a variable named <tt>lag1_cov</tt>.</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement your ToDo here</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_lag1_cov</span>
<span class="n">test_lag1_cov</span><span class="p">(</span><span class="n">resids_new</span><span class="p">,</span> <span class="n">lag1_cov</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="accounting-for-unequal-variance-and-autocorrelation-prewhitening">
<h3>Accounting for unequal variance and autocorrelation: prewhitening<a class="headerlink" href="#accounting-for-unequal-variance-and-autocorrelation-prewhitening" title="Permalink to this headline">¶</a></h3>
<p>So, in summary, if the covariance matrix of your residuals appear to significantly deviate from the identity-matrix scaled by the noise-term (<span class="math notranslate nohighlight">\(\mathrm{cov}[\epsilon] = \hat{\sigma}^{2}\mathbf{I}\)</span>) — either due to unequal variance or non-zero covariance — your estimate of the variance term of your effects (<span class="math notranslate nohighlight">\(\mathrm{var}[c\hat{\beta}]\)</span>) will be incorrect.</p>
<p>Unfortunately, even after high-pass filtering (which corrects for <em>most</em> but not <em>all</em> autocovariance), the covariance matrix of the residuals of fMRI timeseries usually do no conform to the Markov-Gauss assumptions of equal variance and zero covariance. Fortunately, some methods have been developed by statisticians that transform the data such that the OLS assumptions hold again. One such technique is called <em>prewhitening</em>.</p>
<p>Prewhitening uses an estimate of the error covariance matrix — usually denoted by <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> — to account for possible unequal variance and/or autocovariance of the residuals. The matrix <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> is an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix (<span class="math notranslate nohighlight">\(N\)</span> referring to the number of timepoints of your signal), and  may be estimated using different techniques, with names such as “ARMA”, “AR(1)”, and “REML”. In this course, we won’t discuss these techniques and instead assume that your software of choice (FSL, AFNI, SPM) has computed an accurate estimate of <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> for you already. But if you’re up for a (programming) challenge, you can do the <em>optional</em> ToDo below.</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (optional, ungraded)
<p>The “AR(1)” method is a relatively “easy” way to estimate <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>. It computes only a single parameter, the lag-1 correlation (not covariance!). Then, it assumes that the correlation decreases exponentially as a function of lag:</p>
<div class="amsmath math notranslate nohighlight" id="equation-54ef356b-6121-41ce-9001-c19fab6a4b6c">
<span class="eqno">(53)<a class="headerlink" href="#equation-54ef356b-6121-41ce-9001-c19fab6a4b6c" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathrm{autocor}_{\tau} = \phi^{\tau + 1}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi\)</span> is the estimated lag-1 correlation. For example, for <span class="math notranslate nohighlight">\(\phi = 0.9\)</span>, <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> would look like:</p>
<div class="amsmath math notranslate nohighlight" id="equation-2aaf16de-597b-49a0-940d-1dd29fd3b29d">
<span class="eqno">(54)<a class="headerlink" href="#equation-2aaf16de-597b-49a0-940d-1dd29fd3b29d" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathbf{V} = \begin{bmatrix}
                 1.0 &amp; 0.9 &amp; 0.9^{2} &amp; 0.9^{3} &amp; \dots &amp; 0.9^{N-1} \\
                 0.9 &amp; 1.0 &amp; 0.9 &amp; 0.9^{2} &amp; \dots &amp; 0.9^{N-2} \\
                 0.9^{2} &amp; 0.9 &amp; 1.0 &amp; 0.9 &amp; \dots &amp; 0.9^{N-3} \\
                 0.9^{3} &amp; 0.9^{2} &amp; 0.9 &amp; 1.0 &amp; \dots &amp; 0.9^{N-4} \\
                 \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
                 0.9^{N-1} &amp; 0.9^{N-2} &amp; 0.9^{N-3} &amp; 0.9^{N-4} &amp; \dots &amp; 1.0
             \end{bmatrix}
\end{align}\]</div>
<p>Compute the lag-1 correlation below and create the corresponding AR(1) matrix of the residuals (<tt>resids_new</tt>) and store this in a variable named <tt>V_ar1</tt> (do not use the <tt>toeplitz</tt> function for this).</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the (optional) ToDo here.&#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the optional ToDo above. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">toeplitz</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">-</span> <span class="n">t0</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">@</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t1</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">t0</span> <span class="o">-</span> <span class="n">t0</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t1</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">V_ans</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">**</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">resids_new</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">V_ans</span><span class="p">,</span> <span class="n">V_ar1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Suppose you have a signal of 20 timepoints (an irrealistically low number, but just ignore that for now) and that you already estimated the covariance matrix of the residuals of this signal. Now, suppose you take a look at it and you notice that it looks faaaaar from the identity-matrix (<span class="math notranslate nohighlight">\(\mathbf{I}\)</span>) that we need for OLS.</p>
<p>For example, you might see this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">phi</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">**</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="c1"># This will increase variance over time</span>
<span class="n">V</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;V (actual covariance matrix)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (volumes)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Time (volumes)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Identity-matrix (assumed matrix)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="c1">#axes[1].colorbar()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (volumes)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_106_0.png" src="../../_images/temporal_preprocessing_106_0.png" />
</div>
</div>
<div class='alert alert-info'> 
    <b>ToThink</b> (0 points): In the above cell, the <tt>phi</tt> variable controls the amount of autcorrelation (technically, it is the $\phi$ parameter of an AR(1) autocorrelation model). Try changing the value of this variable. Do you understand the way the plotted $V$ matrix is changing as a function of $\phi$? 
</div><p>Well, shit. We have both unequal variance (different values on the diagonal) <em>and</em> non-zero covariance (some non-zero values on the off-diagonal). So, what to do now? Well, we can use the technique of prewhitening to make sure our observed covariance matrix (<span class="math notranslate nohighlight">\(\mathbf{V}\)</span>) will be “converted” to the identity matrix! Basically, this amounts to plugging in some extra terms to formula for ordinary least squares. As you might have seen in the book/videos, the <em>original</em> OLS solution (i.e., how OLS finds the beta-parameters is as follows):</p>
<div class="amsmath math notranslate nohighlight" id="equation-52799032-bb03-4bb2-9905-53c66e7d1e85">
<span class="eqno">(55)<a class="headerlink" href="#equation-52799032-bb03-4bb2-9905-53c66e7d1e85" title="Permalink to this equation">¶</a></span>\[\begin{align}
\hat{\beta} = (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}y
\end{align}\]</div>
<p>Now, given that we’ve estimated our covariance matrix of the residuals, <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>, we can rewrite the OLS solution such that it prewhitens the data (and thus the covariance matrix of the residuals will approximate <span class="math notranslate nohighlight">\(\hat{\sigma}^{2}\mathbf{I}\)</span>) as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-e418d69d-fc78-4e0b-8214-af9674c7789e">
<span class="eqno">(56)<a class="headerlink" href="#equation-e418d69d-fc78-4e0b-8214-af9674c7789e" title="Permalink to this equation">¶</a></span>\[\begin{align}
\hat{\beta} = (\mathbf{X}^{T}\mathbf{V}^{-1}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{V}^{-1}y
\end{align}\]</div>
<p>Then, accordingly, the standard-error of any contrast of the estimated beta-parameters becomes:</p>
<div class="amsmath math notranslate nohighlight" id="equation-a8a771df-dcc2-4743-ad4a-0c39a09cd2cf">
<span class="eqno">(57)<a class="headerlink" href="#equation-a8a771df-dcc2-4743-ad4a-0c39a09cd2cf" title="Permalink to this equation">¶</a></span>\[\begin{align}
SE_{\mathbf{c}\hat{\beta}} = \sqrt{\hat{\sigma}^{2} \cdot \mathbf{c}(\mathbf{X}^{T}\mathbf{V}^{-1}\mathbf{X})^{-1}\mathbf{c}^{T}}
\end{align}\]</div>
<p>This “modification” of OLS is also called “generalized least squares” (GLS) and is central to most univariate fMRI analyses! You <em>don’t</em> have to understand how this works mathematically; again, you should only understand <em>why</em> prewhitening makes sure that our data behaves according to the assumptions of the Gauss-Markov theorem.</p>
<p>(Fortunately for us, there is usually an option to ‘turn on’ prewhitening in existing software packages, so we don’t have to do it ourselves. But it is important to actually turn it on whenever you want to meaningfully and in an unbiased way interpret your statistics in fMRI analyses!)</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): Given the target signal (<tt>some_sig</tt>), design-matrix (<tt>some_X</tt>), and the (hypothetical) covariance-matrix of the residuals from before (the variable <tt>V</tt>), calculate the beta-parameters using the prewhitened version of OLS (i.e., 'generalized least squares'; the formula above). Also, calculate the $t$-value of the contrast <tt>[0, 1]</tt> given the appropriate (GLS) computation of the standard-error. Store your results in the variable <tt>betas_gls</tt> and <tt>tval_gls</tt>, respectively.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement your ToDo here!</span>
<span class="n">some_sig</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span>  <span class="c1"># y</span>
<span class="n">some_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="mi">20</span><span class="p">,</span> <span class="p">:]</span>   <span class="c1"># X</span>
<span class="n">c_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># the contrast you should use</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the optional ToDo above &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_gls_todo</span>    
<span class="n">test_gls_todo</span><span class="p">(</span><span class="n">some_sig</span><span class="p">,</span> <span class="n">some_X</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">c_vec</span><span class="p">,</span> <span class="n">betas_gls</span><span class="p">,</span> <span class="n">tval_gls</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (<em>optional!</em> 0 points)
<p>When it comes to estimating parameters from data with unequal (co)variance, OLS actually still gives you unbiased parameters: on average, they will be correct. However, OLS is not the estimator with least variance anymore, meaning that it is less “precise” (it is not the “Best Linear Unbiased Estimator” anymore; still unbiased, but not the “best”). In fact, with unequal (co)variance, GLS is the best unbiased linear estimator. A good way to build intuition about this is to iteratively generate data with known parameters (the “true betas”, <span class="math notranslate nohighlight">\(\beta\)</span>, “sigma squared”, <span class="math notranslate nohighlight">\(\sigma^{2}\)</span>, and <span class="math notranslate nohighlight">\(V\)</span>) and to estimate the parameters back from the generated data. Then, you can plot the histograms of the parameters and you’ll see that, on average, the estimated parameters are the same as the true parameters.</p>
<p>Below, we set up such a “simulation” loop for you. We define the true parameters (<tt>true_betas</tt>, <tt>siqsq</tt>, <tt>V</tt>). Now, if you’re up to the challenge, complete the loop by:</p>
<ol class="simple">
<li><p>Generating some random design matrix (e.g., using <tt>np.random.normal</tt> of size (N, 1));</p></li>
<li><p>Stack an intercept</p></li>
<li><p>Generate correlated noise using the <tt>np.random.multivariate_normal</tt> function (with <tt>cov=V</tt>);</p></li>
<li><p>Generate the data using the formula <span class="math notranslate nohighlight">\(X\beta + \mathrm{noise}\)</span>;</p></li>
<li><p>Estimate the OLS parameters, and store in <tt>betas_ols</tt>;</p></li>
<li><p>Estimate the GLS parameters, and store in <tt>betas_gls</tt>;</p></li>
<li><p>In the next cell, plot both parameters (<tt>betas_ols[:, 1]</tt> and <tt>betas_gls[:, 1]</tt>) as histograms</p></li>
</ol>
<p>Do the histograms look like you expected? Also, try changing the <tt>phi</tt> parameter, which controls the amount of autocorrelation in the data (it’s the AR1 parameter which is used to create <tt>V</tt>). What happens to the difference between OLS and GLS?</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">true_betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">iters</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">phi</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># AR1 parameter</span>
<span class="n">sigsq</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">sigsq</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">**</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

<span class="n">betas_ols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iters</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">betas_gls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iters</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
    <span class="c1"># YOUR CODE HERE</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="more-on-nuisance-regression">
<h2>(More on) nuisance regression<a class="headerlink" href="#more-on-nuisance-regression" title="Permalink to this headline">¶</a></h2>
<p>Let’s go back to the technique of nuisance regression. We have seen before that this technique can be used to model low-frequency components in our data (effectively functioning as a high-pass filter), but it can, in general, be used to model <em>any</em> thus-far unmodelled variance in the signal that would otherwise end up in the noise term. For example, people use this technique to model variance due to physiological processes (such cardiac and respiratory related signals; see e.g. <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/10893535">Glover et al., 2000</a>), motion-related variance (which we’ll discuss later), and high-intensity “spikes”. To get a better feel for nuisance regression and its consequences, let’s look at this process of removing high-intensity spikes (which is sometimes called “despiking”).</p>
<div class="section" id="using-nuisance-regression-for-despiking">
<h3>Using nuisance regression for despiking<a class="headerlink" href="#using-nuisance-regression-for-despiking" title="Permalink to this headline">¶</a></h3>
<p>This technique of adding noise-predictors to the design matrix is sometimes used to model ‘gradient artifacts’, which are also called ‘spikes’ (which you’ve heard about in one of the videos for this week). This technique is also sometimes called “despiking”. These spikes reflect sudden large intensity increases in the signal across the entire brain that likely reflect scanner instabilities. One way to deal with these artifacts is to “censor” bad timepoints (containing the spike) in your signal using a noise predictor.</p>
<p>But what defines a ‘spike’/bad timepoint? One way is to compute the normalized “root mean square successive differences” (RMSSD), normalizing this, and imposing some threshold above which a timepoint is marked as a spike (technically, it’s a little bit more complex, but we’ll ignore that for now).</p>
<p>We’ll delve into the details of this computation later. For now, let’s take a look at some example data that we’re going to use for this section:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;spike_data.npz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">spike_data</span><span class="p">:</span>
    <span class="n">all_sig</span> <span class="o">=</span> <span class="n">spike_data</span><span class="p">[</span><span class="s1">&#39;all_sig&#39;</span><span class="p">]</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">spike_data</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of all_sig: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">all_sig</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of pred: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shape of all_sig: (10, 10, 10, 500)
Shape of pred: (500, 1)
</pre></div>
</div>
</div>
</div>
<p>The example data <code class="docutils literal notranslate"><span class="pre">all_sig</span></code> is a (simulated) 4D fMRI scan with <span class="math notranslate nohighlight">\(10 \times 10 \times 10\)</span> voxels and 500 timepoints (assuming a TR of 2, this amounts to a duration of 1000 seconds). The predictor reflects a design in which the participants was shown a stimulus every 100 seconds (50 TRs). Let’s plot the predictor:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (TRs)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Activation (A.U.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/temporal_preprocessing_118_0.png" src="../../_images/temporal_preprocessing_118_0.png" />
</div>
</div>
<p>Alright, now let’s take a look at how you would calculate the “root mean square successive differences” (RMSSD). This quantity reflects the difference between every timepoint <span class="math notranslate nohighlight">\(t\)</span> of your signal and the signal at timepoints <span class="math notranslate nohighlight">\(t-1\)</span>, which is then squared, averaged (across all voxels, <span class="math notranslate nohighlight">\(1 \dots K\)</span>), after which the square root is taken:</p>
<div class="amsmath math notranslate nohighlight" id="equation-dc2750c2-069f-4b1f-801b-f558a6d26198">
<span class="eqno">(58)<a class="headerlink" href="#equation-dc2750c2-069f-4b1f-801b-f558a6d26198" title="Permalink to this equation">¶</a></span>\[\begin{align}
\mathrm{RMSSD}_{t} = \sqrt{\frac{1}{K}\sum_{K}(s_{t, k} - s_{t-1, k})^2}
\end{align}\]</div>
<p>First, let’s focus on the “successive differences”. Suppose we have only one “signal” of length 5:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ex_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>The “successive differences” are the difference between 3 and 1, -2 and 3, 0 and -2, and 5 and 0. Note that the successive difference for the first timepoint (<span class="math notranslate nohighlight">\(t=0\)</span>) is not defined! In code, we can compute this with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">succ_diff</span> <span class="o">=</span> <span class="n">ex_sig</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ex_sig</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">succ_diff</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 2 -5  2  5]
</pre></div>
</div>
</div>
</div>
<p>After computing the successive differences, we need to do another thing. As we noted earlier, RMSSD is not defined for <span class="math notranslate nohighlight">\(t=0\)</span> (because there is no <span class="math notranslate nohighlight">\(t-1\)</span> for the first timepoint). We can insert a duplicate of the first value here for convenience.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">succ_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">succ_diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">succ_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
<b>ToDo</b> (optional; 0 point): Compute the RMSSD of the data. Note that our data (<tt>all_sig</tt>) has 4 dimensions, with the fourth dimension representing time. Store the result in a variable named <tt>all_sig_rmssd</tt>, which should have the same shape as the original signal. Also, try to do this without a for-loop by making using of vectorization.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute the sucessive differences here</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo (optional). &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_rmssd</span>
<span class="n">test_rmssd</span><span class="p">(</span><span class="n">all_sig</span><span class="p">,</span> <span class="n">all_sig_rmssd</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
<b>ToDo</b> (optional; 0 points)
<p>Now, in order to identify spikes, we need to identify timepoints that have a RMSSD-values that differ more than (let’s say) 7 standard deviations from the mean RMSSD value. As such, you need to ‘z-score’ the RMSSD values: subtract the mean value from each individual value and divide each of the resulting ‘demeaned’ values by the standard deviation (<span class="math notranslate nohighlight">\(\mathrm{std}\)</span>) of the values. In other words, the z-transform of any signal <span class="math notranslate nohighlight">\(s\)</span> with mean <span class="math notranslate nohighlight">\(\bar{s}\)</span> is defined as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-3edf25af-33fd-44ef-86c9-ed713005b866">
<span class="eqno">(59)<a class="headerlink" href="#equation-3edf25af-33fd-44ef-86c9-ed713005b866" title="Permalink to this equation">¶</a></span>\[\begin{align}
z(s) = \frac{(s - \bar{s})}{\mathrm{std}(s)}
\end{align}\]</div>
<p>Implement this z-score transform for the variable <tt>all_sig_rmssd</tt> and store it in the variable <tt>z_rmssd</tt> (1 point). Then, plot the z-scored RMSSD signal (with appropriate axis labels; 1 point).</p>
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s load the correct answer from the previous optional ToDo</span>
<span class="c1"># in case you didn&#39;t do it</span>
<span class="n">all_sig_rmssd</span> <span class="o">=</span> <span class="n">test_rmssd</span><span class="p">(</span><span class="n">all_sig</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Implement the z-scoring below</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests part 1 of ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_zscore_rmssd</span>
<span class="n">test_zscore_rmssd</span><span class="p">(</span><span class="n">all_sig_rmssd</span><span class="p">,</span> <span class="n">z_rmssd</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now, plot the zscored rmssd signal (z_rmssd)!</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we can set a threshold above which we define timepoints as “spikes”. Let’s say we do this for <span class="math notranslate nohighlight">\(z &gt; 7\)</span>.</p>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the correct answer from the previous (optional) ToDo</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_zscore_rmssd</span>
<span class="n">z_rmssd</span> <span class="o">=</span> <span class="n">test_zscore_rmssd</span><span class="p">(</span><span class="n">all_sig_rmssd</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">identified_spikes</span> <span class="o">=</span> <span class="n">z_rmssd</span> <span class="o">&gt;</span> <span class="mi">7</span>  <span class="c1"># creates array with True/False</span>
<span class="n">n_spike</span> <span class="o">=</span> <span class="n">identified_spikes</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%i</span><span class="s2"> spikes in the data!&quot;</span> <span class="o">%</span> <span class="n">n_spike</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, to remove this influence, we can simply add a nuisance predictor for each spike, in which the predictor contains zeros at timepoints without the spike and 1 at the timepoint with a spike.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spike_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pred</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n_spike</span><span class="p">))</span>
<span class="n">t_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">identified_spikes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_spikes</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating spike predictor for t = </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">spike_pred</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spike_pred</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (TRs)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Activation (A.U.)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pred</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Creating spike predictor for t = 100
Creating spike predictor for t = 300
</pre></div>
</div>
<img alt="../../_images/temporal_preprocessing_135_1.png" src="../../_images/temporal_preprocessing_135_1.png" />
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (1 point):
<p>Why do you think we do not convolve the spike regressors with an HRF (or basis set)? Write your answer in the text-cell below.</p>
</div><p>YOUR ANSWER HERE</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 points): Calculate the <em>t</em>-value of the stimulus-predictor-against-baseline contrast in a model with both the stimulus predictor (<tt>pred</tt>) and the spike predictors (<tt>spike_pred</tt>). Also, stack an intercept. Store the <em>t</em>-value in the variable <tt>tval_spike_model</tt>. Use <tt>spike_sig</tt> (defined below) as your target, i.e., $y$.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the t-value of the model with only an intercept + stim predictor</span>
<span class="n">spike_sig</span> <span class="o">=</span> <span class="n">all_sig</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">:]</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nii.week_4</span> <span class="kn">import</span> <span class="n">test_spike_model</span>
<span class="n">test_spike_model</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">spike_pred</span><span class="p">,</span> <span class="n">spike_sig</span><span class="p">,</span> <span class="n">tval_spike_model</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (1 point): An eager researcher might think that adding more and more (nuisance) predictors will always improve the amount of variance explained and thus will improve his/her chances of finding significant effects (i.e., $t$-values). Argue why this is not the case.
</div><p>YOUR ANSWER HERE</p>
<div class='alert alert-success'>
    <b>Tip!</b>
    Before handing in your notebooks, we recommend restarting your kernel (<em>Kernel</em> &rarr; <em>Restart & Clear Ouput</em>) and running all your cells again (manually, or by <em>Cell</em> &rarr; <em>Run all</em>). By running all your cells one by one (from "top" to "bottom" of the notebook), you may spot potential errors that are caused by accidentally overwriting your variables or running your cells out of order (e.g., defining the variable 'x' in cell 28 which you then use in cell 15).
</div></div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./fMRI-introduction/week_4"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="../../section_intros/4_preprocessing.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Preprocessing</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="spatial_preprocessing.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Spatial preprocessing</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Lukas Snoek<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>